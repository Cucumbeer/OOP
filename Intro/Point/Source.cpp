#include <iostream>
using namespace std;

#define tab "\t"
#define delimiter "\n---------------------------------------------------------------\n"
//#define STRUCT_POINT
#define DISTANCE_CHECK
//#define CONSRUCTORS_CHECK
//#define ASSIGMENT_CHECK
//#define CONSTRUCTORS_OVERLOADING
class Point
{
	double x;
	double y;

public:
	double get_x()const
	{
		return x;
	}
	double get_y()const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}

	//Constructors:
#ifdef CONSTRUCTORS_OVERLOADING
	Point()
	{
		//Конструктор по умолчанию: 
		x = y = 0;
		cout << "Constructor:\t" << this << endl;
	}
	Point(double x)
	{
		//Конструктор с одним параметром: 
		this->x = x;
		this->y = 0;
		cout << "Single argument constructor: \t" << this << endl;
	}
#endif // CONSTRUCTORS_OVERLOADING

	Point(double x = 0, double y = 0) 
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t\t" << this << endl;
	}
	Point (const Point& other)
	{
		// Shallow copy 
		this->x = other.x;
		this->y = other.y;
		cout << "Copy constructor:\t" << this << endl;
	};

	~Point()
	{
		cout << "Destructor:\t\t" << this << endl;
	}

	//Operators:

	Point& operator=(const Point& other)
	{
		this->x = other.x;
		this->x = other.y;
		cout << "Copy Assignment:\t\t" << this << endl; 
		return *this; 
	}
	

	
	//Methods: 

	double distance(const Point& other)
	{
		//B - this ;  A - other;
		double x_distance = this->x - other.x;
		double y_distance = this->y - other.y;
		double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
		return distance;
	}
	
	void Print()const
	{
		cout << "X = " << x << tab << "Y = " << y << endl;
	}
};

double distance(const Point& A, const Point& B)
{
	double x_distance = A.get_x() - B.get_x();
	double y_distance = A.get_y() - B.get_y();
	double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
	return distance;
}

void main()
{
	setlocale(LC_ALL, "");
#ifdef STRUCT_POINT


	Point A;   // Создание объекта 
	A.x = 2;
	A.y = 3;
	cout << A.x << tab << A.y << endl;

	Point* pA = &A;  //Объявляем указатель на Point и берем адрес точки А
	cout << pA->x << tab << pA->y << endl; 
#endif // STRUCT_POINT

#ifdef DISTANCE_CHECK
	Point A;
	A.set_x(2);
	A.set_y(3);
	cout << A.get_x() << tab << A.get_y() << endl;
	Point B;
	B.set_x(4);
	B.set_y(5);
	cout << delimiter << endl;
	cout << B.distance(A) << endl;
	cout << delimiter << endl;
	cout << distance(A, B) << endl;
	cout << delimiter << endl;
#endif // DISTANCE_CHECK

#ifdef CONSRUCTORS_CHECK
	Point A;		//Default constructor
	A.Print();
	Point B = 3;    //Single-argument constructor 
	B.Print();
	Point C(2, 3);  //Parametrised constructor
	C.Print();
	Point D = C;    //Copy constructor
	D.Print();
	Point E;
	E = C;          //Copy Assignment
	E.Print();
#endif // CONSTRUCTORS_CHECK

#ifdef ASSIGMENT_CHECK

	int a, b, c;
	a = b = c = 0;
	cout << a << tab << b << tab << c << endl;

	Point A, B, C;
	cout << "\n----------------------------------------\n";
	A = B = C = Point(4, 5);
	cout << "\n----------------------------------------\n";
	A.Print();
	B.Print();
	C.Print();

#endif // ASSGMNMENT_CHECK

}

 /*  Структура и класс - это тип данных
    Объект являются переменными пользовательского типа. 
	Объект класса или структуры еще называют экземпляром класса или структуры
	Для обращения к полям объектов можно использовать . либо ->
	. - Оператор прямого доступа (Point operator). Используется для доступа к полям объекта по имени объекта.
	-> - Оператор косвенного доступа (Arrow operator). Используется к полям объекта по адресу объекта. 
	get - методы должны быть константными.
	Константным называется метод, который не изменяет объект для которого вызывается. 
	this - это указатель на объект, для которого вызывается метод. 
	Внутри метода невозможно узнать имя объекта, для которого метод вызвался, но всегда можно узнать адрес объекта при помощи this.
	В любом классе обязательно должны быть: конструктор, деструктор и оператор присвоить. 
	Constructor - это метод, который создает объект
	Destructor - это метод, который уничтожает объект по завершении его времени жизни. 
	Время жизни объекта истекает при завершении области видимости, в которой он объявлен. Это относится к локальным объектам.

	for (int i = 0; i < 5; i++)  // Здесь счетчик i является локальным объектом для цикла for
								 //Он сущетвует только в зоне видимости цикла, и по завершении всех итераций этот объект будет уничтожен.
	{
		cout << i << tab;
	}
	cout << endl;
	Point A создан в области видимости функции main и будет уничтожен по завершении функции main. 
	Конструктор и деструктор называется так же как и класс, но перед деструктором ставится '~'
	Конструктор может принимать параметры, поэтому его как и любую другую функцию можно перегрузить, а значит в классе может быть сколько угодно конструкторов. 
	Деструктор не может принимать параметры и его нельзя перегрузить, поэтому в классе может быть только один деструктор. 

	Написать метод distance, который возвращает расстояние до указанной точки. ***
	Написать функцию distance, которая возвращает расстояние между двумя точками. *** 

	Конструкторы бывают: с параметрами, без параметров, по умолчанию, конструктор копирования и конструктор переноса. 
	Конструктор по умолчанию - это конструктор, который может быть вызван без параметров. 
	Это может быть конструктор, не принимающий никаких параметров, или же конструктор с параметрами, каждый параметр которого имеет значение по умолчанию.
	Конструктор копирования может быть неявным. Неявный конструктор выделяет память под объект и заполняет его переменные мусором. 
	Конструктор по умолчанию вызывается всякий раз, когда мы хотим просто создать объект, но не знаем каким он будет.
	Конструктор по умолчанию должен заполнять переменные объекта значениями по умолчанию.
	Конструктор может принимать сколько угодно параметров, и таких параметров может быть сколько угодно в классе. 
	Конструкторы тоже пожно перегрузить. 
	Конструктор копирования - это метод, который копирует объект. Он выделяет память под объект и копирует содержимео другого другого объекта в наш.
	Это особенно важно при использовании в классе динамической памяти.
	В этом случае конструктор копирования должен выделить память оператором new и выполнить побитовое(поэлементное) копирование динамической памяти другого объекта в наш.
	Если не написать конструктор копирование, то компилятор сам его добавит.
	Такой конструктор выполняет так называемое поверхностное копирование объекта (Shallow copy). Т.е просто копирует переменные из одного объекта в другой. 
	Если переменная - указатель на динамическую память, то неявный конструктор копирования просто скопирует адрес, что недопустимо при использовании динамической памяти. 
	Конструктор копирования всегда принимает константную ссылку на другой объект. 
	Довольно часто объект нужно сделать точной копией другого объекта, не только при его создании, а и после после создания
	Но конструктор копирования может быть вызван только при создании объекта, как и любой другой конструктор
	И для того, чтобы копировать объекты после их создания в классе должен быть оператор присваивания.
	Он делает то же самое, что и конструктор копирования, но после создания объекта, то есть для уже существующего объекта 
	Ошибка С2668 ambiguous call to overloaded function - Неоднозначный вызов перегруженной функции.

		ПЕРЕГРУЗКА ОПЕРАТОРОВ 
	Перегрузка операторов нужна для более удобной работы с объектами. Для того чтобы над объектами можно было выполнять такие же операции, как и над обычными переменными. 
	Перегруженные операторы - это самые обычные функции, имя которых состоит из ключевого слова operator и знака оператора.
	Операторы можно перегружать как в классе, так и за классом. Если оператор перегружен в классе, то он является методом, а метод быть вызван только для объекта.
	Если оператор перегружен за классом, то он является обычной глобальной функцией. 
	Если бинарный унарный оператор перегружен в классе, то он не принимает никаких параметров, а его единственным операндом является объект, для которого он вызывается.
	Если же унарный оператор перегружен за классом, то он в обязательном порядке должен принимать один и только один параметр - свой операнд.
	Если бинарный оператор перегружается в классе, то он может принимать только один параметр - операнд справа, а его операндом слева является объект, для которого он вызывается (this).
	Если бинарный оператор перегружен за классом, то он в обязательном порядке должен принять два параметра - операнд слева и операнд справа.
	Есть операторы которые могут изменять операнды, некоторые не могут. 
	Те операторы, которые должны изменять свои операнды лучше пергрузить в классе, а те операторы, которые не могут изменять операнды лучше перегружать за классом.
	Правила перегрузки операторов: 1) Перегрузить можно только существующие операторы, нельзя создавать новые операторы. 2) Не все существующие операторы можно перегрузить
	Не перегружаются: ?: - тернарный оператор (if); :: - Оператор разрешения области видимости; . - Point operator; .* - Pointer to member selection; # - Stringizing operator; # - Token-pasting operator;
	3) Перегруженные операторы сохраняют приоритет и ассоциативность. 
	4) Нельзя изменить поведение операторов со встроенными типами данных.

 */